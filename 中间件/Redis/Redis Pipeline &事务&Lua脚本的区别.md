# Redis Pipeline &事务&Lua脚本的区别

## 区别和联系

**原生批指令**
如 redis 1.0 版本就提供的 mget 指令，可以在一条指令内批量读取/设置kv对。本身是原子性的，且单条命令在网络交互和服务端处理上，性能都很高。

**Pipeline 流水线**
将指令在客户端的缓冲区里打包，最后一次性发送，重点在于节省多次发送指令的网络开销。
和事务&Lua有以下几个区别：

1. 这是纯客户端行为，服务端无感知，也没有进行对应的特殊处理。
2. 不阻塞服务端执行其他客户端的指令，即没有串行化
3. 无法在一个PPL内，一个指令读取上一个指令的结果


服务端执行两个客户端的Pipeline时序图：

![img](https://pic3.zhimg.com/80/v2-b93cc73d5644c936c84a0d67b0e836ee_720w.webp)



**事务**
将每条命令缓存在服务端的一个队列中，提交时再一次性执行。
和Pipeline的区别如下：

1. 服务端感知，每次客户端发送单指令都和服务端交互。[网络开销大可结合PPL优化]

2. 严格串行化，会阻塞事务之外其他客户端命令的执行。

3. 如果遇到指令的语法错误，会在提交前即入队列时暴露出来。

4. 拥有 watch 指令功能，相当于一种乐观锁。

   

**Lua 脚本**
   从能力上看， Lua 相当于 Pipeline 和 事务优势的结合，并提供了更强大的能力。一般在开发中代替原生提供的事务。
   主要的区别在于：

5. 可自定义复杂逻辑，如if-else，高级运算符等。

6. 具有编译缓存能力，进一步提高性能。

7. 和PPL比是严格串行化的。




**注意点**

1. 根据[原子性的定义](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Atomicity_(database_systems))：一个事务内，多个操作要么全部执行成功，要么全部不执行。那么 Pipeline、事务、Lua 都不具备原子性，因为单条指令的失败都不会阻碍其他执行的实际执行, 并没有"回滚"概念。
2. 各种批量方式执行的指令不宜过多过长，一方面是阻塞其他客户端，另一方面是服务端和客户端发送&接收的socket缓冲区可能放不下